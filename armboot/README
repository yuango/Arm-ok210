**2017/4/15	first release
**本例修改启动文件，实现杀死原uboot并取代
**代码先烧写到0x20008000处，再通过原uboot写到nandflash的0x0地址处，则重启后就会自动运行该类似uboot引导功能程序
**210中在内存0x0地址处固化了iROM,其中完成了看门狗，定时器，ICATCH，栈和变量等对初始化(详见原厂资料)
**SRAM是内置的可以使用，而外置DRAM没初始化是不能用的
**ok210中硬件只支持nandflash和sd卡烧写两种方式，所以irom之后自动从nand的0x0地址开始读数据并运行

**程序从start开始执行，但irom读程序对前16字节不当指令执行，而是看做校验值，0x2000指整个程序大小(可改,默认最多读8kb，超过部分的uboot代码会被搬运到内存的0x23e000000处)
**start开始应该将栈(用于程序运行使用)设置在SRAM(0xd0020000)中，因为DRAM(0x20008000)还没初始化不能用,所以main.lst文件中的0x20004000地址(因为是基于当前的uboot，所以可以运行在动态RAM中，已经初始化了DRAM)应该修改为0xd0020000，因为如果把原来的uboot删除就不能使用DRAM(还没初始化呢不能用)
**DRAM在哪初始化？IROM中？在lowlevel_init中初始化时钟和DRAM
**启动文件中至少包括4个部分，先是硬件初始化lowlevel_init，包括时钟和DRAM；然后是软件初始化,包括栈初始化(7种模式栈分配)和bss清空(循环赋值0)
**********未完成**************
———————————————————————————————————————————————————————————


NFSTAT是状态位，原应只能被读取来观察某种状态，而RB信号中[4]位如果向其写1，则有清除该位作用(不可直接写0来清除)
0x800为2K字节的页

ok210中内核存在nandflash的地址0x100000处，大小0x500000
本程序只能将nand中的内核内容读到内存0x20008000处运行
nand中是小端存储，第一周期传出的数显示时在最低位

**2017/10/10 second release
**main.lst链接脚本用于将各文件编译生成的.o文件合并成一个可执行文件，每个.o文件都包含三个部分:文本段(.text)、数据段(.data)以及.bss段



start.S(详细看文档)

.text

.global start//

.word 0x2000//标志IROM要读走的文件大小
.word 0x0
.word 0x0
.word 0x0//前16字节IROM读取当作校验

start://位置应该就是链接文件中的设置ENTRY地址
	msr cpsr_c,#0xd3
	ldr sp,=0xd0036000//设置程序栈在内置SRAM地址，栈能使用SRAM不能使用未初始化的DRAM(栈地址与.txt地址是分开的，程序从.txt位置开始运行，其过程以及环境都压入栈位置)
	sub sp,sp,#12
	@;....自写初始化...clk,dram,sp,bss

	bl uart_run//相当于main 函数，如果有参数就在之前给R0,R1,R2(参数)赋值
	b .//上面运行结束回来就死循环(实际以下可以设计为正常启动的运行代码,而调用uart_run相当于我们在开发板启动时加载内核之前进入命令端操作，如果没有运行uart_run则正常代码就是引导加载内核等工作)

------------------------------------------------------------------------------------------------------
2018-0801 updata uboot

start.S以及其他一些uboot过程使用到的功能文件编译生成了.bin二进制文件，将之存到NAND FLASH的开头位置，之后IROM会从NAND中读前8K字节数据到SRAM中，
而读到SRAM中的位置由链接脚本中ENTRY(程序运行入口地址)决定。uboot在SRAM中开始执行，读到.bin文件的前16字节用于校验是否从NAND中读出8K字节数据，
接着开始执行启动文件的内容，设置栈位置在0xd0036000(栈是向下低地址生长)，则uboot执行的上下文都存储在该位置的栈中。
uboot需要完成启动文件中的各种初始化功能，并且从NAND中加载内核镜像，然后运行该镜像，其中内核启动参数需要在DRAM中设置好。(文件系统也是由uboot加载进内核并运行)。
